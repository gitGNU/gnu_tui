#!/usr/bin/env bash
#	Yet Another Simple Script Installer
# ------------------------------------------------------------------------
# Copyright (c) 2015 Simon Arjuna Erat (sea)  <erat.simon@gmail.com>
# All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>
#
#
#	Created:	2015.02.27
#	Transformed:	2015.12.07
#	Changed:	2015.12.09
	script_name=configure
	script_version=1.99-BETA
#
#	Description:
#		This script automaticly, according to passed options, 
#		generates the following files, named to go along with GNU Automake terminology.
#		* make
#		* make-install
#		* make-uninstall
#		* make-clean
#		* make-distclean
#		* make-doc-{info,html,dvi,pdf,ps}
#		* Makefile
#
#		It can also create a REFERENCE file ($APP_dirs.conf) and if 'doRef=true',
#		it will copy that file to $SYSCONFDIR automaticly, as well as remove it when uninstalling
#		
#		The options were applied from the output of GNU Automake's './configure --help'
#		and the calculation of the paths is done according to: http://www.pathname.com/fhs/
#
#		This is not about auto magic compiling,
#		this is about simply placing files - with some required extras.
#
#
#	To report bugs or suggestions about YASSI (configure), please raise an issue on:
#		* https://github.com/sri-arjuna/yassi/issues
#	or send me an email with the subject YASSI.
#
# ------------------------------------------------------------------------
#
#	Clear data of previous / other runs
#
	unset CHROOT DESTDIR
	unset ${!APP_*} ${!AUTHOR_*} ${!MAINTAINER_*} ${!MAILLIST_*} BUGTRACKER
	unset DOWNLOAD_IF_MISSING DOWNLOAD GIT SVN
	unset REQS DEPS DOCS MAKE PRIOR POST UNINSTALL CLEAN DISTCLEAN IGNORE CHECK INSTALLDIRS
	unset doMakefile doGNU doTUI doRef
	unset ${!DIR_*} #${![AZ]]*_DIR}
#
#	Set Commands, bypass alias'
#
	AWK=\gawk
	GREP=\grep
	INSTALL=\install
	LS=\ls
	SED=\sed
	WHICH=\which
#
#	Prepare cleared arrays and variables
#
	# Arrays
	declare -A FHS DOCS REQS 
	declare -a MAKE PRIOR POST UNINSTALL CLEAN IGNORE CHECK INSTALLDIRS
	# Variables
	declare APP_NAME="APPNAME" APP_VER APP_LIC \
			APP_TITLE APP_PRJ APP_HOMEPAGE \
			APP_DIR="${PREFIX:-/usr/local}"
	declare AUTHOR_NAME AUTHOR_EMAIL AUTHOR_HOMEPAGE
	declare MAINTAINER_NAME MAINTAINER_EMAIL MAINTAINER_HOMEPAGE
	declare BUGTRACKER DOWNLOAD_IF_MISSING DOWNLOAD GIT SVN DEPS
	declare CFG="${CFG:-./configure.yassi}" REF MANPAGE="/tmp/yassi.1"
	# Bools
	declare doMakefile=false doGNU=false doTUI=false doRef=false
	declare VERBOSE=false DEBUG=false
	# Basic 'compatiblity' with the 'prepass V=[1|2] toggle'
	[ -n "$V" ] && VERBOSE=true
#
#	Message Strings
#
	[ -f "$CFG" ] && source "$CFG"
	case "${APP_LANG:-eng}" in
	eng)	MSG_NO_CONFIG="Configuration file ($CFG) not found!"
		MSG_NO_NAME="Missing APP_NAME..."
		MSG_NO_INTERNET="No working internet connection found."
		MSG_NO_REQS="Did not find the following required commands:"
		MSG_CANNOT_EXE_DIR='Cannot execute a directory: $1!'
		MSG_MISSING_CMDS="Please provide these commands before configuring $APP_NAME!"
		MSG_NO_TEXI="The command 'texi2any' was not found, which is required to create this manual"
		MSG_TARBALL_GOOD="Successfully created tarball"
		MSG_TARBALL_BAD="There was an error building the tarball"
		MSG_=""
		;;
	esac
#
#	Default path list
#
	mandirs="mandir $(echo man{1..9}dir)"
	list_index="prefix bindir sbindir  sysconfdir datarootdir appdir icondir datadir docdir htmldir infodir $mandirs dvidir pdfdir psdir compldir sharedstatedir localstatedir rootdir bootdir efidir grubdir"
	list_variables="";for i in $list_index;do list_variables+=" ${i^^}";done
#
#	Version & Help
#
	show_version() {
	# Prints the version of the script
	# and exits
		cat <<-EO_SCREEN
		./configure, Version $script_version
		Copyright (C) 2015 by Simon Arjuna Erat, erat.simon@gmail.com
		License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
		
		This is free software; you are free to change and redistribute it.
		There is NO WARRANTY, to the extent permitted by law.

		Report bugs of ./configure to: https://github.com/sri-arjuna/yassi/issues
		EO_SCREEN
		exit 111
	}
	show_paragraph() { # NODE "CONTENT"
	# Prints a helptext block
	# that is usable as manpage 
		printf "\n%s\n" "${1^^}" ; shift
		for a in "${@}";do printf "\t%s\n" "$a";done
	}
	show_help() {
	# Prints the helpscreen
	# and exits
		[ -n "$APP_LIC" ] && \
			scr_lic="$(show_paragraph license "${APP_NAME:-APPNAME}: ${APP_LIC}" " ")" || \
			src_lic=""
		app_ver=""
		[ -n "$APP_VER" ] && \
			 app_ver=" (${APP_VER})" || \
			 app_ver=""
		
		cat <<-EO_SCREEN
		SYNOPSIS
		  	./$script_name [options]
		
		DESCRIPTION
		 	Routine to configure the installation of "${APP_TITLE:-${APP_NAME:-APPNAME}}$app_ver"
		$scr_lic
		OPTIONS-BASIC
		 	-h|--help		Shows this screen and exits
		 	--version		Shows the version of YASSI (./configure) and exits
		 	--verbose		Prints all the action on the screen
		
		 	--prefix DIR		Sets the prefix to DIR		(default: PREFIX=${APP_DIR})
			
		OPTIONS-DIRS	
		 	--bindir DIR		user executeables 		(\$PREFIX/bin)
		 	--sysconfdir DIR	read-only single-machine data 	(\$PREFIX/etc)
		 	--datadir DIR		read-only architecture-independent data (\$DATAROOTDIR/${APP_NAME:-APPNAME})
		 	--compldir DIR		Bash completion				(\$DATAROOTDIR/bash-completion/completions)
		 	
		 	--datarootdir DIR	read-only arch.-independent data root 	(\$PREFIX/share)
		 	--localedir DIR		locale-dependent data			(\$DATAROOTDIR/locale)
		 	--localstatedir	DIR	modifiable single-machine data		(\$PREFIX/var)
		 	--sbindir DIR		admin executeables			(\$PREFIX/sbin)
		 	--sharedstatedir DIR	modifiable architecture-independent	(\$PREFIX/com)
			
		OPTIONS-DOCS
		 	--docdir DIR		Project documentation root	(\$DATAROOTDIR/doc/${APP_NAME:-APPNAME})
		 	--infodir DIR		Info documentation		(\$DATAROOTDIR/info)
		 	
		 	--mandir DIR		Basedir for manpages		(\$DATAROOTDIR/man)
		 	--man[1-9]dir DIR	Specific manpage dirs		(\$MANDIR/man/man[1-9])
		 	
		 	--htmldir DIR		Project documentation root	(\$DOCDIR)
		 	--dvidir DIR		Project documentation root	(\$DOCDIR)
		 	--pdfdir DIR		Project documentation root	(\$DOCDIR)
		 	--psdir DIR		Project documentation root	(\$DOCDIR)
		 	
		OPTIONS-GUI
		 	--appdir DIR		*.desktop files			(\$DATAROOTDIR/applications)
		 	--icondir DIR		Icons for the desktop files	(\$DATAROOTDIR/icons)
		 
		OPTIONS-REDIST
		 	--chroot DIR		Sets the CHROOT to DIR		(for 'builddirs' or before chrooting into a partition)
		 	--tarball		Equivalent of: "./configure [opts] && (./make-tarball || make dist)"
		 	--makefile		Writes a dynamic Makefile according to created scripts
		 	--gnu			Writes a GNU compliant Makefile
		
		OPTIONS-DEVEL
		 	--sample		Prints a mini example for a '$CFG'
		 	--sample-full		Prints a template with all options of a '$CFG'
		 	--sample-full-clean	Prints the same template without comments.
		 	--manpage		Prints an advanced help screen for developers/packagers
		 
		NOTES
		  Common Prefix Locations
		  	Common places that are used as --prefix=DIR:
		  	* / or /usr
		 	* /usr/local or /opt
		 	* \$HOME or \$HOME/usr
		 	* \$HOME/local or \$HOME/.local
		
		EO_SCREEN
		
		# Print messages according to passed configuration file
		[ -n "$AUTHOR_NAME" ] && echo "The project \"${APP_TITLE:-$APP_NAME}\" was written by \"$AUTHOR_NAME\" <$AUTHOR_EMAIL> ($AUTHOR_HOMEPAGE)"
		[ -n "$MAINTAINER_NAME" ] && echo "This package of \"${APP_TITLE:-$APP_NAME}\" is maintained by \"$MAINTAINER_NAME\" <$MAINTAINER_EMAIL> ($MAINTAINER_HOMEPAGE)"
		[ -n "$MAILLIST_NEWS" ] && echo "To stay informed about \"$APP_NAME\", subscribe to: <$MAILLIST_NEWS>"
		[ -n "$MAILLIST_BUGS" ] && echo "To report bugs, please send a descriptive email to <$MAILLIST_BUGS>"
		[ -n "$BUGTRACKER" ] && echo "If you experience any bugs or errors using \"$APP_NAME\", please rais an issue on <$BUGTRACKER>"
		exit 99
	}
	show_manpage() { #
	#
	#	show_paragraph() { # NODE "CONTENT"
		show_paragraph 
		cat <<-EO_SCREEN
			DESCRIPTION
			 	This manpage shall explain how to write/modify a YASSI configuration file.
				
				This manual is still in progress and also describes functionality that is still in developement.
				
			FILES
			 	Assuming you want to install only a single script, 
			 	which resides in the same dir as the configuration:
			 	
			 		APP_NAME=my-app-name-without-spaces
			 		BINDIR=my-app-script.sh
			 	
			 	Say you have two executable scripts, change the BINDIR to:
			 	
			 		BINDIR="my-app-script.sh my-other-script.sh"
		
			DIRECTORIES
			  	Or you might want to place the two scripts in a single directory, 
			  	naming that to something like 'bin':
			 	
			 		BINDIR=bin
			 		
			 	Now in addition, let us assume your application requires additional data.
			 	
			 	Lets say we need to copy two folder and a file into the DATADIR
			 	(eg: /usr/share/appname)
			 	
			 		DATADIR="./datadir ./templatedir docs/extra/dirinfo.txt"
			 	
			DIRECTORIES CUSTOM	
			 	You may define and use custom paths, be aware that you probably have to handle them your own.
			 	
			 	To define a new TARGET DIR, use:
			 	
			 		DIR_DEMO='$DATADIR/demo'
			 		
			 	Then to assing the installer to install files there:
			 	
			 		DEMO_DIR=demo/my*files
			 	
			 	NOTE: This is a hardcore example of what could have been:
			 	
			 		DATADIR=./demo
			 	
			REGEX
			 	If you want to copy only specific items, you can use REGEX to select them.
			 	
			 	In one of my projects i have this as a good example:
			 	
			 		DOCDIR="[CT]* docs/[ACGILNR]* docs/tex/*.html"
			 		
			 	Which would copy all files starting with a capital C or T, 
			 	likewise for all files starting with A C G I L N or R from the docs dir.
			 	
			 	In addition, it also installs all html files from the subdir docs/tex/.
			 	
			 	No directories will be found within this DOCDIR (/usr/share/doc/appname)
				
			DOCS
			 	Is a nice handler to create texi documents.
			 	
			 	Each of the following assignments will create a specific: make-doc-<TYPE> file.
			 	
			 	Supported TYPE's are: info, html, pdf, dvi and ps.
			 	
			 	DOCS[\$TYPE]=docs/texi/\$APP_NAME.texi	The created script will create the info document.
			 	
			 	DOCS[info]="docs/texi\$APP_NAME.texi docs/texi/other-node.texi" Also multiple entries are supported.
			 	
			 	There is no need to handly the 'texi2any' requirement, using DOCS[TYPE] will inform the user if it is missing.
			 	Also, it will not allow the user to delete (./make-clean) these docs if 'texi2any' is not available.
			 	
			 	While this only takes care of creating these docs, you still need to place them for the installation:
			 	
			 		INFODIR=docs/tex/*.info
			 		HTMLDIR=docs/tex/*.html
			 	
			 	Upon ./configure, ./make-doc-<TYPE> will be created.
			 	
			 	Upon ./make-doc-<TYPE>, it will check if 'texi2any' is avilable or not.
			 	
			 	Upon ./make-install-all, all available ./make-doc-* are executed.
			 	
			BOOLEANS
			 	There are a few optional bool'ish helpers, by default they are set to false, they are:
			 	
			 	doMakefile=false	It is quite obvious what doMakefile does if it is set to true.
			 	doGNU=false		If not provided by the author of the project, it adds some targets to the Makefile
			 	doRef=false		installs the reference file of the used paths to /etc/appname.conf, 
						 	if enabled, the file is also uninstalled automaticly.
						 	If you need to apply the systems absolute paths into your scripts, use the \$REF for your TASK's in your $CFG.
			 	doVer=false		Some projects require to have the version in their path name 'doVer' does that.
			 	doTUI=false		As I wrote YASSI for myself, this doTUI toogle will install the Text User Interface,
			 				framework for scripts before the the actual install.
			 	
			 	
			TASKS
			 	If you need to generate some files, for example a file containing the absolute paths of the system it is installed to,
			 	you can do that by adding one or multiple MAKE array entries:
			 	
			 		MAKE[0]="cat scripts/template.sh > bin/myapp"
			 	
			 	You could also let ./make execute other scripts:
			 	
			 		MAKE[1]=scripts/prepare.sh
			 		
			 	Or print a message to the user:
			 	
			 		MAKE[2]='echo "Hello $USER"'
			 	
			 	Likewise for PRIOR[0] and POST[0], but those will be executed before and after the actual installation of the TARGETs.
			 	
			 	The obvious exceptions are: UNINSTALL[0], CLEAN[0], DISTCLEAN[0], and IGNORE[0].
			 	IGNORE is used for --tarball (make dist), the others obvious for their make-<COMMAND>s.
			 	
			REQS
			 	There are two ways to let YASSI check for your project its REQs.
			 	
			 	If the variable REQS is just filled by a single list, 
			 	it will check for any entry of that list to be available in \$PATH using 'which',
			 	and if some entries are missing, it will not create the make-install script.
			 	
			 	However, if you change REQS to become an asociative array, it accepts these modes:
			 	
			 	REQS[app]="bash gawk sed"	Your project requires these commands and cannot run without them
			 	REQS[make]="txt2man"		This command is required to prepare the/your project files
			 	REQS[opt]="shuffle"		This command can improve usablity for your project but is not essential
			 	
			 	Why this destinction?
			 	
			 	In regards of the 'app' it is quite obvious, likewise for the 'opt'.
		 		The 'make' part is there to let redistributors and packages a chance to prepare your project without the need to install the REQS[make] items for all target systems.
		 		
			DEPS
			 	If you have multiple projects prepared with YASSI, you can simple list the filename (.yassi extension optional).
			 	And YASSI will install all of the listed YASSI configure files prior to the install but after PRIOR tasks.
			 	
			 		DEPS="deps/*.yassi"
			 	
			 	Is the equivalent of:
			 	
			 		PRIOR[0]="cd deps"
			 		PRIOR[1]="../configure -c one.yassi"
			 		PRIOR[2]="../configure --conf two.yassi"
			 		PRIOR[3]="cd .."
			 	
			 	Or even just:
			 	
			 		PRIOR[0]="cd deps;../configure -conf one.yassi;../configure -conf two.yassi;cd .."
			 	
			 	However, this only works if that DEP provides a DOWNLOAD, GIT or SVN source..
			 	When downloading a tarball, it expects it to contain a folder named '\$APP_NAME' ($APP_NAME) optional appended by either '-master' or '-\$APP_VER' ($APP_VER).
			 	
			 	Retrieving the project using GIT or SVN is recomended.
			 	
			VARIABLES PRESETS
			 	These variables may be placed in front of ./configure and will influence the behavior of YASSI.
			 	
			 	CFG=file	This is the same as "--conf file"
			 	DESTDIR=dir	This is the same as ./configure --chroot=dir,
			 			but it can also overwrite the previous set CHROOT by
			 			passing "DESTDIR=dir make install"
			 	TARBALL=file	By default the created tarball will reside in the top dir, use this to change the location
			 	
			AUTHOR
			 	YASSI was started in early Feb 2015 by Simon Arjuna Erat from Switzerland.
			 	
			 	
		EO_SCREEN
		#root boot efi grub systemd"
	}
	show_sample() { #
	#
	#
		cat <<-EO_SCREEN
		#!/usr/bin/env bash
		#
		#	Project Info
		#
		 	APP_NAME=		# Install name of the application, \$PREFIX/share/\$APP_NAME
		 #	APP_VER=		# Optional, Show Versionnumber
		 #	APP_LIC=GPLv3+		# Optional, Show License
		 #	AUTHOR_NAME=""		# Optional, Name of author
		 #	AUTHOR_EMAIL=""		# Optional, Email of author
		#
		#	Default target dirs
		#
		 	# Basic
		 	BINDIR=			# Executables
		 	SYSCONFDIR=		# Recomended, see --help for its default path
		 	DATADIR=		# Recomended, see --help for its default path
		 
		 
		EO_SCREEN
		exit 0
	}	
	show_sample_full() { #
	#
	#
		cat <<-EO_SCREEN
		#!/usr/bin/env bash
		# Copyright (c) $(date +'%F') by ${USER_NAME:-USER}  <${USER_EMAIL:-$USER@$HOSTNAME}>
		# All rights reserved.
		#
		# This program is free software: you can redistribute it and/or modify it
		# under the terms of the GNU General Public License as published
		# by the Free Software Foundation, either version 3 of the License, or
		# (at your option) any later version.
		#
		# This program is distributed in the hope that it will be useful,
		# but WITHOUT ANY WARRANTY; without even the implied warranty of
		# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
		# GNU General Public License for more details.
		#
		# You should have received a copy of the GNU General Public License
		# along with this program.  If not, see <http://www.gnu.org/licenses/>
		#
		#
		#	Project Info
		#
		 	APP_NAME=		# Install name of the application, \$PREFIX/share/\$APP_NAME
		 #	APP_VER=		# Optional, Show Versionnumber
		 #	APP_LIC=GPLv3+		# Optional, Show License
		 #	APP_TITLE=""		# Optional, Show long title
		 #	APP_PRJ=""		# Optional, Name the parent project
		 #	APP_HOMEPAGE=""		# Optional, This Project its website
		 #	APP_DIR=/usr/local	# Optional, Used as default PREFIX if none is passed
		#
		#	Author & Package Maintainer Info
		#
		 #	AUTHOR_NAME=""		# Optional, Name of author
		 #	AUTHOR_EMAIL=""		# Optional, Email of author
		 #	AUTHOR_HOMEPAGE=""	# Optional, Website of author
		 #	MAINTAINER_NAME=""	# Optional, Name of author
		 #	MAINTAINER_EMAIL=""	# Optional, Email of author
		 #	MAINTAINER_HOMEPAGE=""	# Optional, Website of author
		 #	MAILLIST_NEWS=""	# Optional, address of maillist to get news
		 #	MAILLIST_BUGS=""	# Optional, address of maillist to send bugs to...
		 #	BUGTRACKER=""		# Optional, adress to visit if no maillist is available
		#
		#	Mini Installer
		#
		 #	DOWNLOAD_IF_MISSING=""	# Optional, If this file is not found, use one of the 3 below methods
		 #	DOWNLOAD=""		# Optional, Url to download package
		 #	GIT=""			# Optional, Retrieve code from git to ./\$APP_NAME.src
		 #	SVN=""			# Optional, Retrieve code from svn to ./\$APP_NAME.src
		#
		#	YASSI Booleans
		#
		 #	doMakefile=false	# Optional, Write a Makefile according to created scripts
		 #	doGNU=false		# Optional, like doMakefile, but write additional TARGETs to the Makefile
		 #	doTUI=false		# Optional, Install TUI
		 #	doRef=false		# Optional, Install \${APP_NAME}_dirs.conf to \$SYSCONFDIR/\$APP_NAME.conf
		 #	doVer=false		# Optional, Use \$APP_VER for the DATADIR (\$DATAROOTDIR/\$APP_NAME-\$APP_VER)
		#
		#	Requirements
		#
		 #
		#	Requirements
		#
		 #	REQS=""			# What commands must be installed
		 #	REQS[app]="bash which"	# Detailed checks, MODE ('app') may be: app, make or opt.
		 #	REQS_ONE[0]="curl wget"	# For each entry at least one of the commands must be found
		 #	DEPS=""			# Install these *.yassi configure files before anything else
		#
		#	Create documentions
		#
		 #	DOCS[info]=		# Optional, Add *.texi files to the list and texi2any will convert them with ./make-doc-info
		 #	DOCS[html]=		# Optional, Add *.texi files to the list and texi2any will convert them with  ./make-doc-html
		 #	DOCS[pdf]=		# Optional, Add *.texi files to the list and texi2any will convert them with  ./make-doc-pdf
		 #	DOCS[dvi]=		# Optional, Add *.texi files to the list and texi2any will convert them with  ./make-doc-dvi
		 #	DOCS[ps]=		# Optional, Add *.texi files to the list and texi2any will convert them with  ./make-doc-ps
		#
		#	Default target dirs
		#
		 	# Basic
		 	BINDIR=			# Recomended, see --help for its default path
		 #	SBINDIR=		# Optional, see --help for its default path
		 	SYSCONFDIR=		# Recomended, see --help for its default path
		 #	DATAROOTDIR=		# Optional, see --help for its default path
		 	DATADIR=		# Recomended, see --help for its default path
		 	COMPLDIR=		# Recomended, see --help for its default path
		 #	LOCALEDIR=		# Optional, see --help for its default path
		 #	LOCALSTATEDIR=		# Optional, see --help for its default path
		 #	SHAREDSTATEDIR=		# Optional, see --help for its default path
		 
		 	# GUI			# --> See "./configure --help" for their default paths
		 #	APPDIR=			# Optional, Install *.desktop files
		 #	ICONDIR=		# Optional, Install according icons
		 
		 #	# Docs
		 #	DOCDIR=			# Recomended, see --help for its default path
		 #	INFODIR=		# Recomended, see --help for its default path
		 #	HTMLDIR=		# Optional, see --help for its default path
		 #	PDFDIR=			# Optional, see --help for its default path
		 #	DVIDIR=			# Optional, see --help for its default path
		 #	PSDIR=			# Optional, see --help for its default path
		 #	MANDIR=			# Optional, see --help for its default path
		 	MAN1DIR=		# Recomended, see --help for its default path
		 #	MAN8DIR=		# Optional, see --help for its default path
		#
		#	Advanced Tweakings
		#
		 #	MAKE_CREATES=		# Optional, If this file is missing, make install wont start
		 #	TARBALL="\${HOME}/\${APP_NAME}.tar.gz"		# Optional, default tarball is: ../\$APP_NAME.tar.gz or ../\${APP_NAME}-${APP_VER}.tar.gz
		 #	MAKE[0]="python ./scripts/script.py"	# Optional, Tasks to be done by ./make
		 #	PRIOR[0]=""		# Optional, Tasks prior to installation (./make-install)
		 #	POST[0]=""		# Optional, Tasks post to installation (./make-install)
		 #	UNINSTALL[0]=""		# Optional, additional tasks to be done by ./make-uninstall, required to undo possible PRIOR or POST operations
		 #	CLEAN[0]="to-delete.file"		# Optional, Tasks to be done by ./make-clean
		 #	DISTCLEAN[0]=""		# Optional, Tasks to be done by ./make-distclean
		 #	IGNORE[0]=".git"	# Optional, Files or Folders that are not used for tarball
		#
		#	Custom Target Paths
		#
		 	# Example
		 # 	DIR_DEMO='$DATAROOTDIR/demos/$APP_NAME'
		 # 	DEMO_DIR=mydata/*
		 	
		EO_SCREEN
		exit 0
	}
	show_sample_full_clean() { #
	#
	#
		show_sample_full | sed s,"	#..*","",g
	}
#	Functions
#	
	task_reference() { # INDEX
	# Prints the index reference used
	#
		ref_val="${FHS[${1,,}]}"
		echo "${1}=$ref_val"  | $SED s,"//","/",g
	}
	task_docs() { # INFILE [TYPE=info]
	# Prints the texi2any command to create an info file
	# or another specified TYPE (dvi,html,pdf,ps)
		INFILE="$1"
		DOCTYPE="${2:-info}"
		OUTFILE=${INFILE/\.*/\.$DOCTYPE}
		
		case "${DOCTYPE,,}" in
		info)	echo "texi2any -o \"$OUTFILE\" --no-split \"$INFILE\""
			;;
		*)	echo "texi2any  --$DOCTYPE -o \"$OUTFILE\" --no-split \"$INFILE\""
			;;
		esac
	}
	task_remover() { # ENTRY
	# Catches ENTRY and prints 'rm -f ENTRY' if it is a file/dir
	# Print the line as-is otherwise
		if [ -f "$1" ]
		then 	echo "rm -f \"$1\""
		elif [ -d "$1" ]
		then 	echo "rm -fr \"$1\""
		elif [ "rm" = "${1:0:2}" ]
		then	case "$1" in
			"rm "*|"rmdir "*)
				echo "$1"	;;
			*)	echo "rm -f $1"	;;
			esac
		else	echo "rm -f $1"
		fi
	}
	task_executer() { # ENTRY
	# Catches ENTRY and prints 'sh ./ENTRY'
	# Executes it, or fails if it is a dir.
		if [ -d "$1" ]
		then 	echo "$(eval $MSG_CANNOT_EXE_DIR)" >&2
			exit 1
		elif [ -f "$1" ]
		then	if [ -x "$1" ] 
			then	[ "/" = "${1:0:1}" ] && \
					echo "\"$1\"" || echo "\"./$1\""
			else	[ "/" = "${1:0:1}" ] && \
					echo "bash \"$1\"" || echo "bash \"./$1\""
			fi
		else	echo "$1"
		fi
	}
	task_clean() { 
	# Remove the files that where created
	# from 'make' or make 'html'
		[ -f make-clean ] || return 
		texi_convert() { # INFILE TYPE
			echo "${1%\.texi}.$2"
		}
		echo "which texi2any 2>/dev/zero 1>/dev/zero || exit 0" >> make-clean
		for T in info html pdf dvi ps;do tData="${DOCS[$T]}" 
			for item in $tData;do echo "rm -f $(texi_convert "$item" "$T")" >> make-clean ;done
		done
	}
	task_distclean() { 
	# Remove all the files that where created by configure
	#
		( $doMakefile || $doGNU ) && echo "rm -f Makefile"
		for task in make* $REF
		do	task_remover "$task"
		done
	}
	task_dist() { #
	# 
	#
		exclude_list=$(echo [mM]ake* *_dirs.conf)
		for ex in "${IGNORE[@]}";do exclude_list+=" $ex";done
		# Since we prepare the make-<files>, configure is no longer required
		opt_exclude="" #"--exclude-ignore=configure"
		for item in $exclude_list;do opt_exclude+=" --exclude-ignore=$item";done
		
		tmp_p="${PWD:-$(pwd)}"
		tmp_dir="$(dirname $tmp_p)"
		[ -z "$APP_VER" ] && \
			VERSION="" || \
			VERSION="_${APP_VER}"
		tarball="${TARBALL:-../${APP_NAME}$VERSION.tar.gz}"
		tar 	-acf "$tarball" \
			--hard-dereference \
			$opt_exclude * && \
			echo "$MSG_TARBALL_GOOD ${tarball}!"
	}
	task_reqs() { # LIST
	# Parse command list of REQS
	# Prints list of missing items and returns 1, 0 if all available
		missing=""
		for req in ${@};do
			$DEBUG && printf '.'
			which $req 2>/dev/zero 1>&2 || missing+=" $req"
		done
		if [ -z "$missing" ]
		then	return 0
		else	printf '%s\n' \
				"$MSG_MISSING_CMDS" #"Sadly, you must figure out the package name yourself."
			printf '::-->> %s\n' \
				${missing}
			exit 1
		fi
	}
	task_download() { #
	#
	#
		tmp=$(\ls -l|\grep -v configure)
		if [ -z "$tmp" ]
		then	# It is empty, so no other files available, get them now

			if [ -n "$DOWNLOAD" ]
			then 	# Tarball is available
				curl -o "$APP_NAME.tar.gz" "$DOWNLOAD"
				tar axf "$APP_NAME.tar.gz"
				cd "$DOWNLOAD_DIR"
				mv * ..
				cd ..
			elif [ -n "$APP_GIT" ]
			then	# Git url is passed, lets check if it is required
				# There are 'code' or '.git' urls
				last_word="${APP_GIT##*/}"
				check_word="${last_word/\.git}"
				if [ "$last_word" = "$check_word" ]
				then	# it is 'code'
					git clone "$GIT" "$APP_NAME"
				else	# its *.git
					git clone "$APP_GIT"
				fi
				mv "$APP_NAME" "$APP_NAME.$$"
				cd "$APP_NAME.$$"
				mv * ..
				cd ..
			else	printf '%s\n' \
					"Fatal error, could not retrieve source code" \
					"Please check if either DOWNLOAD ($DOWNLOAD + $DOWNLOAD_DIR) are set," \
					"or if $APP_GIT provides a valid URL."
				exit 1
			fi
		fi
	}
	load_fhs() { #
	# Assign default paths according to: http://www.pathname.com/fhs/
	# The 'appdir', 'icondir' and the 'man[1-9]dir's are 'homebrew' and non-standard, so are root, bootdir, efidir, grubdir and systemddir
		for index in $list_index
		do
			$DEBUG && printf '.'
			tmp="${FHS[$index]}"
			etc_done=false
			if [ -z "$tmp" ]
			then	case "$index" in
				prefix)		tmp="${APP_DIR}"	;;
				sysconfdir)	tmp_prefix="${FHS[prefix]}"
						case "$tmp_prefix" in
						"/"|"/usr")
							tmp="/etc";;
						*)	if $is_at_home
							then	tmp="$HOME/.local/etc"
							else	tmp="${FHS[prefix]}/etc"
							fi	;;
						esac ; etc_done=true	;;
				# --- ---  --- ---  --- ---  --- ---  --- #
				rootdir)	tmp="/"	;;
				bootdir)	tmp="${FHS[rootdir]}/boot"	;;
				efidir)		tmp="${FHS[bootdir]}/efi"	;;
				grubdir)	tmp="${FHS[bootdir]}/grub"	;;
				systemddir)	tmp="${FHS[sysconfdir]}/systemd";;
				# --- ---  --- ---  --- ---  --- ---  --- #
				"bindir")	tmp="${FHS[prefix]}/bin"	;;
				"sbindir")	tmp="${FHS[prefix]}/sbin"	;;
				datarootdir)	tmp="${FHS[prefix]}/share"	;;
				appdir)		tmp="${FHS[datarootdir]}/applications"	;;
				icondir)	tmp="${FHS[datarootdir]}/icons"	;;
				datadir)	tmp="${FHS[datarootdir]}/$APP_NAME"	;;
				infodir)	tmp="${FHS[datarootdir]}/info"	;;
				mandir)		tmp="${FHS[datarootdir]}/man" ;;
				man[0-9]dir)	tmp="${FHS[mandir]}/${index:0:4}" ;;
				localedir)	tmp="${FHS[datarootdir]}/locale" ;;
				docdir)		tmp="${FHS[datarootdir]}/doc/$APP_NAME" ;;
				htmldir|dvidir|pdfdir|psdir)	tmp="${FHS[docdir]}" ;;
				compldir)	# Some systems have bash completion within the SYSCONFDIR
						if [ -d "${FHS[datarootdir]}/bash_completion/completions" ]
						then 	tmp="${FHS[datarootdir]}/bash_completion/completions"
						elif [ -d "${FHS[sysconfdir]}/bash_completion.d" ]
						then	tmp="${FHS[sysconfdir]}/bash_completion.d"
						else # Use default as fallback
							tmp="${FHS[datarootdir]}/bash-completion/completions"
						fi ;;
				sharedstatedir)	tmp="${FHS[prefix]}/com"	;;
				localstatedir)	tmp="${FHS[prefix]}/var"	;;
				esac
				if [ "$index" = "prefix" ] && ! $etc_done
				then	# Do special handling
					[ "~" = "${tmp:0:1}" ] && tmp="${tmp/~/$HOME}"
					if [ "${tmp:0:${#HOME}}" = "$HOME" ]
					then	is_at_home=true
						install_prefix=""
						tmp="${tmp/~\/$HOME/$HOME}"
					else	is_at_home=false
					fi
				fi
				FHS["$index"]="$tmp"
			fi
		done
		export FHS is_at_home
	}
	write_file_ref() { #
	# Write the basic reference file
	#
		# Exit with error with $REF is not set
		[ -z "$REF" ] && exit 1 ; >"$REF"
		# Internal defaults
		$is_at_home && FHS[prefix]="$prefix_home"
		echo "PREFIX=${FHS[prefix]}">>"$REF"
		for i in $list_variables;do [ -n "${!i}" ] && task_reference "${i^^}" >> "$REF";done
		
		# Custom added dirs
		for D in ${!DIR_*};do
			$DEBUG && printf '.'
			echo "$D=\"${!D}\" " >> "$REF"
		done
	}
	write_file_docs() { #
	# Checks if texi2any is installed and exit if not
	# Converts the texi files to given type
		for type in info html dvi pdf ps;do
			$DEBUG && printf '.'
			#set -x
			if [ -n "${DOCS[$type]}" ]
			then 	printf '%s\n' \
					'! which texi2any 2>/dev/zero 1>/dev/zero && \' \
					"	echo \"$MSG_NO_TEXI\" && \\" \
					'	exit 1' \
					>> make-doc-$type
				for entry in ${DOCS[$type]};do
					task_docs "$entry" "$type" >> make-doc-$type
				done
			fi
			#set +x
		done
	}
	write_file_headers() { #
	# Creates the ./make* files 
	# and writes the according script headers
		# Basic files
		touch make make-{install,uninstall,distclean}
		$doGNU && touch make-clean make-dist
		[ -n "$(echo ${DOCS[*]})" ] && touch make-install-all
		[ -n "$(echo ${CLEAN[*]})" ] && touch make-clean
		[ -n "$(echo ${DISTCLEAN[*]})" ] && touch make-distclean
		# Docs
		for t in info html dvi pdf ps;do
			[ -n "$(echo ${DOCS[$t]})" ] && touch make-doc-$t
		done
		# Write shebang and make the scripts executable
		for m in ./make*;do
			$DEBUG && printf '.'
			printf '%s\n' "#!/usr/bin/env bash" > "$m" ; chmod +x $m
			# Write special content
			case "$m" in
			make)		printf '%s\n' "source $REF" "$tmp_var" >> "$m"	;;
			*install*)	tmp_var="CHROOT=\${DESTDIR:-$CHROOT}"
					printf '%s\n' "source $REF" "$tmp_var" >> "$m"
					if [ "$m" = "make-install" ] && ! echo "$CHROOT/$PREFIX"| $GREP -q -e /home -e /Users -e /users
					then 	printf '%s\n' "[ \${UID:-0} -ne 0 ] && \\"  \
						printf '\t%s\n' "echo \"To ${m/*-} '${APP_TITLE:-APP_NAME}', root access is required.\" && \\" "exit 99" >> "$m"
					fi ; unset tmp_var 	;;
			esac ; $VERBOSE && printf '%s\n' "set -x" >>  "$m"
		done
		# Write $REF handlers
		if ${doRef:-false}
		then	printf '%s\n' "mkdir -p ${CHROOT}${FHS[sysconfdir]}" \
				"cp $REF ${CHROOT}${FHS[sysconfdir]}/$APP_NAME.conf" >> "make-install"
			printf '%s\n' "rm -f ${CHROOT}${FHS[sysconfdir]}/$APP_NAME.conf" >> "make-uninstall"
		fi
	}
	
	write_files_content() { #
	# Write the actual content of the scripts
	#
		write_array() { # FILE ARRAY
		# Expand passed ARRAY and write 
		# its content to passed FILE
			C=0;F="$1" ; shift
			while 	item="$(eval echo \${${1}[$C]})"
				[ -n "$item" ]
			do 	case "$F" in
				*clean*|*uninst*)
					task_remover "$item" >> "$F" 	;;
				*)	task_executer "$item" >> "$F" 	;;
				esac
				((C++))
			done
		}
		write_file_install() { #
		# Parse all variables and expand them
		# TODO :: DIR_* and *_DIR are handled here
			# Actualy write the make-{un,}install scripts
			for index in $list_variables ${!DIR_*}
			do	# Expand index
				case "$index" in
				DIR_*)	tmp1="${index/*_}_DIR"
					tmp="${!tmp1}"	;;
				*)	tmp="${!index}" ;;
				esac
				task_install "$index" "$tmp"
			done
		}
		# Actually write the content
		for m in make*;do
			$DEBUG && printf '.'
			case "$m" in
			"make")		write_array $m MAKE 		;;
			"make-install")	[ -n "$MAKE_CREATES" ] && \
						echo "[ ! -f \"$MAKE_CREATES\" ] && echo 'Please run either \"./make\" or \"make\" first!' && exit 1" >> "$m"
					write_array "$m" PRIOR
					write_file_install
					write_array "$m" POST		;;
			"make-check")	write_array "$m" CHECK	 	;;
			"make-uninstall")
					write_array "$m" UNINSTALL 	;;
			"make-clean")
					write_array "$m" CLEAN
					task_clean >> "make-clean"	;;
			"make-dist")	echo "source $CFG" >> make-dist
					LC_ALL=C type task_dist | ${GREP:-\grep} -v "is a" >> make-dist
					echo task_dist >> make-dist	;;
			"make-distclean")
					write_array "$m" DISTCLEAN 
					>> "make-distclean"
					task_distclean >> "make-distclean";;
			esac
		done
	}
	write_file_closer() { #
	# Saves the return code of the last command 
	#
		for m in ./make*
		do	$VERBOSE && verbose="set +x" || verbose=""
			printf '%s\n' "RET=\$?" "$( [ -n "$verbose" ] && echo $verbose)" "exit \$RET" >> "$m"
		done
	}
	task_mkdir() { # INDEX
	# Print the code required to create a directory
	# Checking for '/usr-move' and creates symlink if required
		grep -q "create_dir=\"${FHS[${1,,}]}\"" make-install && return
		cat >> "make-install" <<-EO_SCREEN
		
		create_dir="${FHS[${1,,}]}"
		if [ ! -d "\${CHROOT}\${create_dir%/*}" ]
		then 	cd "\${CHROOT}/usr/.."
		 	[ -d "\${CHROOT}/usr\${create_dir%/*}" ] && [ -n "\${create_dir%/*}" ] && \\
		 		ln -sf "usr\${create_dir%/*}" "./\${create_dir%/*}"
		 	cd "\$OLDPWD"
		fi
		#[ -d "\${CHROOT}\$create_dir" ] || \\
			mkdir -p "\${CHROOT}\$create_dir" || echo >/dev/zero
		EO_SCREEN
	}
	task_install() { # INDEX CONTENT
	#
	#
		# Vars 
		INDEX="$1" ; shift
		DEST="${CHROOT}${FHS[${INDEX,,}]}"
		# func
		get_dir() { # Entry
			. "$REF" ; tmp="${1/DIR_}"
			#[ ! "$1" = "$tmp" ] && tmp="${1/DIR_}_DIR" || \
				tmp="$1"
			echo "${!tmp}";unset tmp
		}
		skip_this() { # Entry
			A=$(get_dir DATADIR)
			B=$(get_dir DOCDIR)
			for E in $A $B;do
				len=${#E}
				[ ! "$APP_NAME" = "${E##*/}" ] && continue
				[ "${1:0:$len}" = "$E" ] && return 0
			done
			return 1
		}
		
		# Parse each 'variable'
		for item in ${@}
		do 	ID=${INDEX^^}
			tPath="$(get_dir ${INDEX})"
			tItem="${!ID}"
			# This expansion must not have quotes!
			
			DEST="${DEST:-$tPath}"
			
			# Something to do?
			[ -n "$tItem" ] && \
				task_mkdir "$INDEX" >> make-install || \
				continue
			skip_this && continue
			
			# Parse each item of the tList
			for lItem in $tItem;do
				$DEBUG && printf '.'
				tList=$(eval echo $lItem)
				unset ${!str_*}
				# Install - very new
				if [ -d "$lItem" ]
				then	# Install
					[ "./" = "${lItem:0:2}" ] && \
						str_inst="cp -pr \"$lItem\" \"$tPath\""  || \
						str_inst="cp -pr \"$lItem\"/* \"$tPath\"" 
					# Uninstall
					for e in "./$lItem/"*
					do 	[ -d "$e" ] && \
							str_rem="rm -fr $DEST/${e##*/}" || \
							str_rem="rm -f $DEST/${e##*/}"
					done
				elif [ -f "$lItem" ]
				then	# Install
					str_inst="cp -p \"$lItem\" \"$tPath\""
					# Uninstall
					str_rem="rm -f \"$tPath/$lItem\""
				else	## Pobably not yet available....
					# Install
					str_inst="cp -p \"$lItem\" \"$tPath\""
					# Uninstall
					str_rem="rm -f \"$tPath/$lItem\""
				fi
				# only print to file if command is neither empty nor present yet
				[ -n "$str_inst" ] && ! $GREP -q "$str_inst" make-install && echo "$str_inst"| sed s,"//","/",g >> "make-install"
				[ -n "$str_rem" ] && ! $GREP -q "$str_rem" make-uninstall && echo "$str_rem"| sed s,"//","/",g >> "make-uninstall"
			done
		done
	}
	write_file_make() { #
	# Checks for existing scripts and adds them to the makefile
	# Create it either dynamic or add additional make targets
	#
	#	Variables
	#
		# Clear / Init makefile
		$doMakeFile || return
		local M="./Makefile"
		echo "# This Makefile was generated on $(date +'%F') using YASSI ($script_version)" >$M
	#
	#	Function
	#
		regular_handling() { #
		# Write the basic Makefile
		#
			for task in ./make*
			do 	[ "task" = "all" ] && task=install-all
				case "$task" in
				./make)		printf '%s\n' "options:" "	./make"  >> "$M"				;;
				./make-install-all)
					 	if [ -f "$task" ];then
					 		printf '%s\n' "./make" ./make-doc-* "DESTDIR=\$DESTDIR ./make-install" >> "$task"
						fi 
						[ -f "$task" ] && printf '%s\n' "${task/\.\/make-}:" "	DESTDIR=\$DESTDIR $task"  >> "$M"
						 ;;
				./make-install)	[ -f "$task" ] && printf '%s\n' "${task/*-}:" "	DESTDIR=\$DESTDIR ${task}"  >> "$M" ;;
				*-doc-*)	[ -f "$task" ] && printf '%s\n' "${task/*-}:" "	${task}"  >> "$M" 	;;
				*)		[ -f "$task" ] && printf '%s\n' "${task/*-}:" "	${task}"  >> "$M" 		;;
				esac
			done
			echo "PHONY: $(echo make-*|sed s,make\-,,g|sed s,doc\-,install\-,g)" >> "$M"
			
		}
		add_gnu_mods() { #
		#
		#
			echo $FUNCNAME todo
			return 
			
			mostlyclean
			maintainer-clean
			installdirs

		}
	#
	#	Action & Display
	#
		if $doGNU
		then	# Make the Makefile GNU compliant
			regular_handling
			add_gnu_mods
		else	# Regular default handling
			regular_handling
		fi
	}
#
#	Get options
#
	[ -f "$CFG" ] && source "$CFG"		# Overwrite YASSI defaults and load APP-defaults
	GETOPT=$(getopt \
		--options	"hc:t" \
		--longoptions	"help,version,verbose,conf:,manpage,makefile,sample,sample-full,sample-full-clean,chroot:,tarball,bindir:,sbindir:,prefix:,datarootdir:,datadir:,infodir:,mandir,man[1-9]dir:,localedir:,docdir:,compldir:,sharedstatedir:,localstatedir:,localedir:,rootdir:,bootdir:,efidir:,grubdir:,systemddir:" \
		--name 		"${0##*/}" -- "${@}"
	)
	eval set -- "$GETOPT"
	while true
	do 	case "$1" in
		-h|--help)	show_help		;;
		--version)	show_version		;;
		--sample)	show_sample		;;
		--sample-full)	show_sample_full	;;
		--sample-full-clean)	show_sample_full_clean ; exit 0	;;
		
		--prefix|--bindir|--sbindir|--datarootdir|--datadir|\
		--infodir|--sysconfdir|--mandir,--man[1-9]dir|\
		--docdir|--htmldir|--dvidir|--pdfdir|--psdir|\
		--compldir|--sharedstatedir|--localstatedir|--localedir|\
		--rootdir|--bootdir|--efidir|--grubdir)
				FHS["${1/--}"]="$2"
				shift 2		;;
		-t|--tarball)	task_dist
				exit $? 		;;
		-c|--conf)	CFG="$2"
				shift 2		;;
		--chroot)	CHROOT="$2"
				shift 2		;;
		--makefile)	doMakefile=true
				shift		;;
		--manpage)	if txt2man --help > /dev/zero
				then 	show_manpage | \
						txt2man \
							-t "configure 1" \
							-r "YASSI $script_version" \
							-I "/usr/share/doc/appname" \
							-I "/etc/appname.conf" \
							-I "./make-" \
							-I "./configure" \
							-B "doMakefile" \
							-B "doTUI" \
							-B "doGNU" \
							-B "doRef" \
							> "$MANPAGE"
					man "$MANPAGE" ; rm "$MANPAGE"
				else 	show_manpage
				fi
				exit 0		;;
		--verbose)	VERBOSE=true	;;
		--)		shift ; break	;;
		esac
	done
	[ ! -f "$CFG" ] && echo "$MSG_NO_CONFIG" && exit 1 || source "$CFG"
	[ -z "${APP_NAME/APP*NAME}" ] && echo "$MSG_NO_NAME" && exit 1
	REF="./${APP_NAME}_dirs.conf"
#
#	Prepare Environment
#
	$DEBUG && printf '.'
	load_fhs
	unset ${list_variables}
	source "$CFG"
	write_file_ref
#
#	Prepare installation script
#
	write_file_headers
	write_files_content
	write_file_docs
	write_file_make
	write_file_closer
#
#	Quit
#
	RET=$?
	$DEBUG && set +x
	
