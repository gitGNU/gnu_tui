#!/usr/bin/env bash
# ------------------------------------------------------------------------
#
# Copyright (c) 2014-2015 by Simon Arjuna Erat (sea)  <erat.simon@gmail.com>
# All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>
#
# ------------------------------------------------------------------------
#
#	A simple tool which returns the string of the selected num-id
#
#
#
#	Variable environment
#
	BORDER_RIGHT=""
	# Source only the most required files, 
	# create the RC and load all variable if RC is not present yet.
	source "$HOME/.tui_rc" && \
		. "$TUI_FILE_CONF_COMMANDS" && \
		. "$TUI_FILE_CONF_COLORS" && \
		. "$TUI_FILE_CONF_STATUS" && \
		. "$TUI_FILE_CONF_SYSTEM"  || \
		. tui
	# If there is a user theme directory, use that one instead
	[ -d "$TUI_DIR_USER_THEMES" ] && TUI_DIR_THEMES="$TUI_DIR_USER_THEMES"
	. "$TUI_DIR_THEMES/$TUI_THEME" 
	# Use custom BORDER_RIGHT if it was set
	[ -z "$BORDER_RIGHT" ] && \
		for((i=${#BORDER_LEFT}-1;i>=0;i--)); do BORDER_RIGHT="$BORDER_RIGHT${BORDER_LEFT:$i:1}"; done
#
#	Variables
#	
	ME=${0##*/}
	script_version=0.7
	counter=0
	AUTO=false
	COLUMNS=$(tput cols)
	help_text="
$ME ($script_version)
Usage: 		$ME [options] LIST 'of items' ..
Examples:	ret=\$($ME one two three)
		$ME *
Where options are:
		-a	Autoselect if only one entry was found
"
#
#	Action
#
	ROWS=""
	while getopts "ha" opt
	do	case "$opt" in
		h|"")	printf "$help_text"
			exit 99
			;;
		a)	AUTO=true
			;;
		1|2)    ROWS=$opt
			;;
		esac
	done
	shift $(($OPTIND - 1))
	[ -z "$ROWS" ] || ROWS="-$ROWS"
	
	# This many digits to read at max
	ARGS=("${@}")
	len=${#ARGS[@]}
	$AUTO && \
		[ $len -eq 1 ] && \
		printf '%s\n' "$ARGS" > /dev/stdout && \
		exit 0
	
	# Show the options
	tui-list $ROWS "${ARGS[@]}" > /dev/stderr
	
	# Repeat input while invalid
	invalid=true
	todo=false
	while $invalid
	do	# Reset input line
		#tui-printf ">" > /dev/stderr
                #printf "\r$BORDER_LEFT > " > /dev/stderr
		printf "\r${BORDER_LEFT} >   \r${BORDER_LEFT} > " > /dev/stderr 
		invalid=false
		
		# Get input
		read -n ${#len} NUM
		[ -z "$NUM" ] && invalid=true && continue
		NUM=$(echo "$NUM")
		
		# It is a number in range?
		if [ "" = "$(echo "$NUM"|tr -d [:digit:])" ] && [ ${#NUM} -ne 0 ]
		then	# This some solves the selection of the last item....
			[ $NUM -eq ${#ARGS[@]} ] && NUM=0
			
			# Clear input if NUM is too high
			if [ $NUM -gt $[ $len - 1 ] ]
			then	invalid=true
				printf "\r$BORDER_LEFT >   \r$BORDER_LEFT >" > /dev/stderr
			else	[ $NUM -eq 0 ] && todo=true
			fi
			
			# Array starts at 0
			NUM=$(( $NUM - 1 ))
		else 	# Clear input if NUM is NOT numeric
			printf "\r${BORDER_LEFT} >   \r${BORDER_LEFT} > " > /dev/stderr 
		fi
	done
	$todo && printf "\n" > /dev/stderr
	# Make 'nice to have' linebreak when read automaticly stops reading
	if [ ${#NUM} -eq ${#len} ] 
	then	# Only print newline character if the entered number as the longest number
		printf "\n" > /dev/stderr
	fi
	
	# This is the output
	printf '%s\n' "${ARGS[$NUM]}" > /dev/stdout
