#!/usr/bin/env bash
#
# Copyright (c) 2014-2015 Simon Arjuna Erat (sea)  <erat.simon@gmail.com>
# All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>
#
# ------------------------------------------------------------------------
#
	source "$HOME/.tui_rc" && \
		. "$TUI_DIR_CONF/commands.conf" || \
		. tui	# This first call would create the RC if its missing.
#
#	Author: 	Simon Arjuna Erat (sea)
#	Contact:	erat.simon@gmail.com
#	License:	GNU General Public License (GPL)
#	Created:	2014.04.26
#	Changed:	2015.06.03
	script_version=0.9.4
#	Description:	Simply displays a rotating line on the left side
#			The line rotates upon each call
#
#	Variables
#
	TITLE="Progress indicator"
	ME="${0##*/}"
	help_text="
$ME ($script_version)
$TITLE
Usage: 	$ME [options] ['Message']

Where options are:
	-h(elp) 		This screen
	-b(ar)			Enables the 'bar' mode (minimal)
	-B(ar)	        VAL     Changes the bar-symbol to VAL
	-c(urrent)	VAL	Required fÃ¼r bar-mode
	-C(learline)		Clear the line before print a new value, recomended if you pass multiple files
	-m(ax)		VAL	If provided, changes progressstring output to 'calculated-num / VAL '
	-l(ong)			Prints more info when in bar mode.
	-i(dent)	VAL	VAL is used as part of tempfile name tui-progress use, if used in multiple instances
				Should be provided if used with -m
	-r(eset)		Resets the tempfile, should be used before one is passing -

When called without options, it simply displays a rotating dash (-/|\) on the right side.
When called with option '-m NUM' it increments the number found in the tempfile, and showing [ incr/NUM ], before using this mode, you should reset the tempfile (-r), or use a specific tempfile identifier (-i STRING_ID).
You can overwrite the requirement for a tempfile, if you pass '-c NUM'.
When called with '-b', the options '-m NUM' and '-c NUM' are both required.

"
	ID_CUR=$$
	ID=""
	INDI=( '\' '|' '/' '-' )
	TOTAL=$[ ${#INDI[@]} -1 ]
	TYPE=dash
	MAX=1
	VAL=0
	CURRENT=0
	CLEARLINE=false
	valPassed=false
	hadOpts=false
	doReset=false
	longBar=false
	hasID=false
	BAR='='
	PROGRESS=""
#
#	Functions
#
	reset_temp() { # ID
	# Resets the counter according to passed ID
	#
		if $hasID
		then	tui-conf-set "$TMPFILE" "$ID" 1
		else	echo 1 > "$TMPFILE"
		fi
		#echo was here
	}
	save_tmp() { # VAL
	# Saves VAL in the tempfile according to passed id
	#
		[ -z "$1" ] && return 1
		if $hasID
		then	tui-conf-set "$TMPFILE" "$ID" $1
		else	echo $1 > "$TMPFILE"
		fi
		#echo was here too
	}
	read_tmp() { 
	# Reads VAL in the tempfile according to passed id
	# Returns VAL
		if $hasID
		then	tui-conf-get "$TMPFILE" "$ID"
		else	cat "$TMPFILE"
		fi
	}
#
#	Catching Arguments
#
	while getopts "c:CB:bi:lm:rh" name
	do 	case $name in
		B)	BAR="$OPTARG"
			hadOpts=true		;;
		b)	TYPE=bar
			hadOpts=true		;;
		c)	CURRENT="$OPTARG"
			valPassed=true
			hadOpts=true		;;
		C)	CLEARLINE=true
			hadOpts=true		;;
		i)	ID="$OPTARG"
			hasID=true
			hadOpts=true		;;
		l)	longBar=true
			hadOpts=true		;;
		m)	MAX="$OPTARG"
			[ dash = $TYPE ] && TYPE=num
			hadOpts=true		;;
		h)	printf "$help_text"
			exit $RET_HELP		;;
		r)	doReset=true
			hadOpts=true		;;
		esac
	done
#
#	Check for all required options
#	
	if $hasID
	then	TMPFILE="$TUI_DIR_CACHE/tui-progress_ids.tmp"
	else	TMPFILE="$TUI_DIR_CACHE/tui-progress_default.tmp"
	fi
	$hadOpts && shift $(($OPTIND - 1)) #|| VAL=$(read_tmp)
	MESSAGE="$1"
	$doReset && \
		reset_temp && \
		exit 0
	
	case "$TYPE" in
	dash)	# Default behaviour, no options
		#>/dev/zero
		$hadOpts || VAL=$(read_tmp)
		;;
	num)	# Create initial tempfile if none exists
		[ ! -f "$TMPFILE" ] && \
			touch "$TMPFILE" && \
			reset_temp || exit 1
		VAL=$(read_tmp)
		;;
	bar)	if [ -z "$CURRENT" ]
		then	# Kind of a workaround
			VAL=$(read_tmp)
			VAL=$(( $VAL + 1 ))
		fi
		if [ -z "$MAX" ] || [ -z "$CURRENT" ]  #|| [ ! $MAX -gt 1 ]
		then	# Improper handling
			tui-status 1 "Usage: $ME [-r] [-m \$MAV_VALUE]  [-bc \$CUR_VALUE] [-l]]  'msg'"
			exit 1
		fi
	esac
#
#	Read initial value from tmpfile
#
	[ ! -z "$(echo $CURRENT|tr -d [[:alpha:]])" ] && \
		VAL=$(read_tmp) || VAL="$CURRENT"
	VAL=${VAL:-0}
	MAX=${MAX:-0}
	#VAL=${VAL/*\/}
#
#	Generate output string
#
	case "$TYPE" in
		dash)	[ $VAL -gt 3 ] && VAL=0
			PROGRESS="[  ${INDI[$VAL]}   ]"
			#VAL=$(($VAL+1))	# Doesnt change a thing?
			;;
		num)	# Dont show if VAL is higher than MAX
			[ $VAL -gt $MAX ] && exit 1
			PROGRESS="[ $VAL / $MAX ]"
			;;
		bar)	# Dont show if VAL is higher than MAX
			[ $VAL -gt $MAX ] && exit 1
			[ -z "$COLUMNS" ] && COLUMNS=$(tput cols)
			if $longBar
			then	# Show also procent
				procent=$( echo $MAX $VAL | $AWK '{print (100/$1*$2) }' )
				[ -z "$MESSAGE" ] && fixer=$(( $fixer - 5 ))
				# The length that is available to print bars
				
				pro=${procent/.*/}
				[ $pro -gt 100 ] && \
					pro=100
				[ $pro -ne 100 ] && \
					cent=$( while IFS="." read P C;do [ -z "$C" ] && echo 00 || echo $C;done<<<$procent) && \
					cent=${cent:0:2} || \
					cent=00
				case ${#pro} in
				#0)	echo impossible	;;
				1)	fixer=13 ;;
				2)	fixer=14 ;;
				3)	fixer=15 ;;
				esac
				
				length=$(( $COLUMNS - (2 * ${#BORDER_LEFT}) - 2 - ${#MESSAGE} - 7 - $fixer  ))
				STATUS="[ ${pro}.${cent}%% ]"
				len=$( echo $length $procent | $AWK '{print ($1/100*$2) }' )
			else	# The length that is available to print bars
				[ -z "$MESSAGE" ] && \
					fixer=10 || \
					fixer=14
				length=$(( $COLUMNS - (2 * ${#BORDER_LEFT}) - 2 - ${#MESSAGE} - $fixer ))
				len=$( echo $length $MAX $VAL | $AWK '{print ($1/$2*$3) }' )
			fi
			
			bars=$(printf '%*s' ${len/.*})
			bars=$(echo "$bars"|$SED s," ","\\$BAR",g)

			bar_total="$(printf '%*s' ${length/.*})"
			bar_total="[${bars}${bar_total:${#bars}}]"
			PROGRESS="$bar_total"
			;;
	#	*)	tui-status 1 "Error, type ($TYPE) is unhandled"	;;
	esac
	[ -z "$PROGRESS" ] && tui-printf -S 1 "Something went terrible wrong..." && exit 1
#
#	Update value for next access
#
	case "$TYPE" in
	dash) 	if [ $VAL -lt 3 ]
		then	num=$(($VAL+1))
			save_tmp $num
		else	save_tmp 0
		fi
		;;
	num)	num=$(($VAL+1))
		save_tmp $num
		;;
	bar)	if ! $valPassed
		then	save_tmp $CURRENT
		fi
		;;
	esac
#
#	Display & Action
#
	$CLEARLINE && printf "\e[2K" &
	if [ -z "$MESSAGE" ]
	then	$longBar && [ $pro -ne 100 ] && [ ! $TYPE = dash ] && PROGRESS+=" "
		$longBar && \
			tui-printf "${PROGRESS}" "${STATUS}" || \
			tui-printf "" "${PROGRESS}${STATUS}"
	else	[ ${pro:-0} -ne 100 ] && [ ! $TYPE = dash ] && PROGRESS+=" "
		tui-printf "$MESSAGE" "${PROGRESS}${STATUS}"
	fi