#!/usr/bin/env bash
# ------------------------------------------------------------------------
#
# Copyright (c) 2014-2015 by Simon Arjuna Erat (sea), erat.simon@gmail.com
# All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License (GPL) as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License (GPL) for more details.
#
# You should have received a copy of the GNU General Public License (GPL)
# along with this program.  If not, see http://www.gnu.org/licenses/gpl.html
#
# ------------------------------------------------------------------------
#
	source /etc/tuirc && \
		break_on_injections "$@" && \
		exit 1
	source "${HOME:-/root}/.tuirc"  2>/dev/zero || source tuirc

#	File:		tui-bgjob-mgr
#	Author: 	Simon Arjuna Erat (sea)
#	Contact:	erat.simon@gmail.com
#	License:	GNU General Public License (GPL)
#	Created:	2014.10.15
#	Changed:	2015.08.06
	script_version=0.9.6
#	Description:	Executes all scripts in parallel, unless LIMIT says different, default 5, disabled 0
#	Resources:	http://www.unix.com/shell-programming-and-scripting/252114-bash-script-manage-background-scripts-running-finished-exit-code.html
#
#
#	Script Environment
#
	ME="${0##*/}"				# Basename of tui-bg-scripts
	ME="${ME/.sh/}"				# Cut off .sh extension
	[ ! "." = "$(dirname $0)" ] && \
		ME_DIR="$(dirname $0)" || \
		ME_DIR="$(pwd)"			# Dirname of tui-bg-scripts
	CONFIG_DIR="$TUI_DIR_USER"		# Configuration directory
	CONFIG="$CONFIG_DIR/$ME.conf"		# Configuration file
	TEMP="$TUI_DIR_TEMP/$ME/$$"		# Make dynamic sub folders, so multiple instances would be possible (but not recommended!)
	tui-bol-root && \
		LOG="$TUI_DIR_LOGS/$ME.log" || \
		LOG="$TUI_DIR_USER_LOGS/$ME.log" # Log file placement according to user
	LIMIT=5
	WAIT=5
	COUNT=false
	QUIET=false
	DEBUG=false
	beVerbose=false
#
#	Translate strings
#
	if [ -z "$TUI_LANG" ] && [ -d "$TUI_DIR_LOCALE/${LANG##\.*}" ]
	then	TUI_LANG="${LANG##\.*}"
	else	TUI_LANG="${TUI_LANG:-en_GB}"
	fi
	LANG_FILE="$TUI_DIR_LOCALE/$TUI_LANG/${ME/tui-}.sh"
	[ -f "$LANG_FILE" ] || LANG_FILE="${LANG_FILE/$TUI_LANG/en_GB}"
	source "$LANG_FILE"
#
#	Functions
#
	show_version() { printf '%s\n' "$TR_MSG_TEXT_VERSION"; }
	show_help() { printf '%s\n' "$TR_MSG_TEXT_HELP"; }
	doLog() { # "MESSAGE STRING"
	# Prints: Time & "Message STRING"
	# See 'tui-log -h' for more info
		tui-log -t "$LOG" "$1"
	}
#
#	Environment checks
#
	[ -d "$TEMP" ] || mkdir -p "$TEMP"
	[ ! -e "$LOG" ] && \
		touch $LOG && \
		doLog "------------------------------------------" && \
		doLog "$(eval_gettext 'Created log file of $ME ($script_version)')" && \
		doLog "------------------------------------------"

#
#	Catching Arguments
#
	[ "--help" = "$1" ] && show_help && exit 99
	[ "--version" = "${1,,}" ] && show_version && exit 0
	while getopts "cdhLl:qvw:" opt
	do 	case $opt in
		h)	show_help
			rm -fr "$TEMP"
			exit $RET_HELP
			;;
		L)	less "$LOG"	
			rm -fr "$TEMP"
			exit $RET_DONE
			;;
		d)	printf "" > "$LOG"
			rm -fr "$TEMP"
			exit $?
			;;
		l)	LIMIT=$OPTARG
			log_msg="$TR_MSG_LOG_LIMIT"
			;;
		c)	COUNT=true
			log_msg="$TR_MSG_LOG_COUNT"
			;;
		q)	QUIET=true
			log_msg="$TR_MSG_LOG_QUIT"
			;;
		v)	beVerbose=true
			log_msg="$(gettext 'Enabled DEBUG mode')"
			;;
		w)	WAIT=$OPTARG
			log_msg="$TR_MSG_LOG_WAIT)"
			;;
		esac
		# Print $log_msg to $LOG and print $log_msg to user if verbosity is enabled
		doLog "$TR_MSG_WORD_OPTIONS $log_msg"
	done
	shift "$(($OPTIND - 1))"
#
#	Variable presets
#
	script_name=( "${@}" )		# Contains all files
	MAX="${#script_name[@]}"		# Max amount of scripts
	script_status=( $(for s in "${script_name[@]}";do echo "3";done) )		# Status with same counter of that file	: done(0) failed(1) running(2) todo(3)
	script_pid=()			# PID with the same counter of that file
	# Counters
	RUN=0			# How many scripts are currently running
	# Verify all scripts are executable
	for script in "${script_name[@]}";do [ -x "$script" ] || chmod +x "$script";done
#
#	Display & Action
#
	DONE=0
	while [ "$DONE" -lt "$MAX" ]
	do	# Loop the menu
		C=0			# Reset counters to prevent 'over counting'
		DONE=0			# How many scripts are 'done' (regardless of status)
		GOOD=0			# How many scripts ended successfully
		if ! "$QUIET"
		then	clear
			tui-header "$TR_MSG_TITLE ($script_version)" "$(date +'%F %T')"
			tui-title "$TR_MSG_WORD_STATUS"
		fi
		
		while [ $C -lt $MAX ]
		do	# Vars
			STATUS="${script_status[$C]}"	# Current status
			RET_FILE="$TEMP/$(basename ${script_name[$C]}).ret"
			TMP="$TEMP/$(basename ${script_name[$C]}).cmd"
			script="${script_name[$C]}"
			
			# Do action according to current status
			case "$STATUS" in
			2)	# IS PID still available?
				pid="${script_pid[$C]}"
				if [ ! -z "$(echo $pid)" ]
				then	if ! ps "$pid" > /dev/zero
					then	# Its finished
						read RET < "$RET_FILE"
						[ -z "$RET" ] && RET=1
						script_status[$C]="$RET"
						((RUN--))
						# Make log file a bit more informative
						msg="end"
						[ $RET -eq 130 ] && msg="$TR_MSG_WORD_CANCEL"
						[ $RET -eq 127 ] && msg="$TR_MSG_WORD_TYPO"
						doLog "$script($pid) ,$msg $RET"
					fi
				else 	source "$LANG_FILE"
					msg="$TR_MSG_TEXT_EMPTY"
					tui-status 1 "$msg"
					doLog "$msg"
				fi
				;;
			3)	# Its TODO, can we start it?
				if [ "$RUN" -lt "$LIMIT" ] || [ "$LIMIT" -eq 0 ]
				then 	script_status[$C]=2
					STATUS=2
					((RUN++))
					[ [./] = "${script:0:1}" ] && PRE="" || PRE="./"
					cmd="\"${PRE}$script\" ; echo \$? > \"$RET_FILE\""
					touch "$RET_FILE"
					"$beVerbose" && \
						echo "$cmd" > "$TMP" && \
						tui-terminal "$TMP" || \
						( eval "$cmd" 1>/dev/zero ) &
					script_pid["$C"]="$!"
					PID="${script_pid[$C]}"
					doLog "$(eval_gettext '$PID starting')"
				fi
				;;
			*)	((DONE++))
				[ "$STATUS" -eq 0 ] && ((GOOD++))
				;;
			esac

			# Display latest status
			if ! "$QUIET"
			then	this_script="${script_name[$C]}"
				source "$LANG_FILE"
				case "$STATUS" in
				0|1)	tui-status "$STATUS" "$TR_MSG_WORD_FINISHED $this_script"  ;;
				2)	tui-status "$STATUS" "$TR_MSG_WORD_RUNNIN $this_script" ;;
				3)	tui-status "$STATUS" "$TR_MSG_WORD_WAITING $this_script"	;;
				127)	tui-status 1 "$TR_MSG_TEXT_TYPO \"$this_script\""	;;
				*)	tui-status 1 "$TR_MSG_TEXT_INVALID"	;;
				esac
			fi
			((C++))
		done
		
		if ! "$QUIET"
		then	tui-echo
			tui-title "$TR_MSG_WORD_SUMMARY"
			tui-echo "$TR_MSG_TEXT_COMPLETED" 	"$DONE/$MAX"
			tui-echo "$TR_MSG_TEXT_CURRENTLY" 	"$RUN/$LIMIT"
			tui-echo "$TR_MSG_TEXT_EXECUTED" 	"$GOOD"
			
			tui-echo
			tui-wait "${WAIT:-5}" "$TR_MSG_TEXT_UPDATE"
			echo
		else	sleep "${WAIT:-5}"
		fi
	done
#
#	Exit how the user want
#
	doLog "$TR_MSG_LOG_FINAL"
	tui-log -e "$LOG" "----------------------------------------------"
	tui-log -e "$LOG" ""
	rm -fr "$TEMP"

	if "$COUNT"
	then	exit "$GOOD"
	else	exit 0
	fi
