#!/usr/bin/env bash
#
# Copyright (c) 2013-2015 Simon Arjuna Erat (sea)  <erat.simon@gmail.com>
# All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>
#
# ------------------------------------------------------------------------
#
#
#	Author: 	Simon Arjuna Erat (sea)
#	Contact:	erat.simon@gmail.com
#	License:	GNU General Public License (GPL)
#	Created:	2013.05.03
#	Changed:	2015.05.10
	script_version=2.0
#	Description:	The absolute core function for TUI
#
#	Variables
#
	BORDER_RIGHT=""
	source "$HOME/.tui_rc" && \
		. "$TUI_DIR_CONF/commands.conf" && \
		. "$TUI_DIR_CONF/colors.conf" && \
		. "$TUI_DIR_CONF/tui.conf" && \
		. "${TUI_DIR_THEMES}/$TUI_THEME"  || . tui	# This first call would create the RC if its missing.
	#. tui				# So it then can load the proper values
	# Prepare for output:
	# from: http://rosettacode.org/wiki/Reverse_a_string#UNIX_Shell
	[ -z "$BORDER_RIGHT" ] && \
		for((i=${#BORDER_LEFT}-1;i>=0;i--)); do BORDER_RIGHT="$BORDER_RIGHT${BORDER_LEFT:$i:1}"; done
	HEAD_BG="$TUI_BACKGROUND"
	HEAD_FG="$TUI_FOREGROUND"
	TITLE_BG="$TUI_COLOR_INVERT$TUI_BACKGROUND"
	TITLE_FG="$TUI_COLOR_INVERT$TUI_FOREGROUND"
#
#	Regular data
#	
	ME="${0##*/}"
	ME_DIR="${0/${0##/*/}}"
	TITLE="$ME"
	help_text="
$ME ($script_version)
Usage: 	$ME [options] [arguments]
	$ME		Prints up to 3 arguments. 
			1: Left
			2: Left, Right
			3: Left, Center, Right
Arguments will tell $ME if and where to colorize, or if to do a linebreak.
Options are:
	-h(elp) 	This screen
	-E(cho)		Simulates 'echo', prints up to 3 strings and a newline.
	-T(itle)	Prints 1st argument centred, if more - aligment like tui-echo
			The inner background is colored white with blue font by default
	-H(header)	Full line has a blue background and white font as default color
	-S(tatus)	Does special handling with the first argument
	-r(eturn)	Optional to '-S', returns to line start, rather than newline where used.

If you want to pass a string with a leading dash (-) to $ME, please provide '--' as argument as well.

"
	FIRST=""
	SECOND=""
	THIRD=""
	COLUMNS=${COLUMNS:-$(tput cols)}
	WIDTH=$COLUMNS
	#((WIDTH -= (${#BORDER_LEFT} + ${#BORDER_RIGHT} + 2))) 	# 2=1 space from left and right border each
	#WIDTH=$[ $WIDTH / 2 * 2 ]		# Make it even 
	doEcho=false
	doHeader=false
	doStatus=false
	doTitle=false
	doReturn=false
	optStyle=""
	NL="\n"
	NUM_ID=""
#
#	Catching Arguments
#
	while getopts "EHTS:hr" name
	do 	case "$name" in
		E|echo) 	doEcho=true
				optStyle="-E"	;;
		H|header)	doHeader=true
				optStyle="-H"	;;
		T|title)	doTitle=true
				optStyle="-T"	;;
		S|status)	doStatus=true
				optStyle="-S"
				NUM_ID="$OPTARG" ;;
		r|return)	doReturn=true
				NL="\r" 	;;
		h|*)		printf "$help_text"
				exit $RET_HELP
				;;
		esac
	done
	shift $(($OPTIND - 1))
	ARGS_COUNT=$#
	
	if $doStatus
	then	# It is tui-status which needs special treatment
	#
	#	Fill array according to return value
	#
		# Status requires first to be numeric
		[ -z "$NUM_ID" ] && \
			tui-printf -S 1 "$ME: For option '-S' the first argument needs to be numeric only!" && \
			exit 1
		
		# get the vars
		source "$TUI_DIR_CONF/status.conf"
		unset retvalue[@]
		retvalue[0]="$TUI_DONE" ;	retvalue[1]="$TUI_FAIL"
		retvalue[2]="$TUI_WORK" ;	retvalue[3]="$TUI_TODO"
		retvalue[4]="$TUI_SKIP" ;	retvalue[5]="$TUI_NEXT"
		retvalue[6]="$TUI_BACK" ;	retvalue[7]="$TUI_CANC"
		retvalue[10]="$TUI_ON"	;	retvalue[11]="$TUI_OFF"
		retvalue[99]="$TUI_HELP";	retvalue[111]="$TUI_INFO"
		
		# Make arguments in order
		case $ARGS_COUNT in
		0)	FIRST=" "
			SECOND=" "
			;;
		1)	FIRST="$1"
			SECOND=" "
			;;
		2)	FIRST="$1"
			SECOND="$2"
			;;
		*)	tui-printf -S 1 "Too many arguments ($#)!"
			exit 1
			;;
		esac
		# For tui-status always use '3' strings
		ARGS_COUNT=3
		THIRD="${retvalue[$NUM_ID]}"	#     = 6+2=8
		len_strings=$[ ${#FIRST} + ${#SECOND} + 8 ]
#	elif $doTitle && [ $ARGS_COUNT -eq 1 ]
#	then	FIRST=" "
#		SECOND="$1"
#		THIRD=" "
#		len_strings=${#SECOND}
#		echo jup
	else
		[ ! -z "$1" ] && FIRST="$1" #&& ((ARGS_COUNT++))
		[ ! -z "$2" ] && SECOND="$2" # && ((ARGS_COUNT++))
		[ ! -z "$3" ] && THIRD="$3" #&& ((ARGS_COUNT++))
		len_strings=$[ ${#FIRST} + ${#SECOND} + ${#THIRD} ]
	fi
	# Prepare temporary display style according to $MODE
	[ ! -z "$4" ] && doMore=true || doMore=false
	[ -z "$optStyle" ] && optStyleTMP="-E" || optStyleTMP="$optStyle"
	$doStatus && optStyleTMP="-E"
#
#	Verify all fit on 1 line
#
	if [ 50 -gt $WIDTH ]
	then	# Screen is too small, should not happend
		for S in "$FIRST" "$SECOND" "$THIRD"
		do 	[ -z "$S" ] || echo "$S"
		done
		exit ${NUM_ID:-0}
	fi
	
	if [ $len_strings -gt $WIDTH ]
	then 	# All vars are larger than the line supports
		# Splitting required
		#echo $ARGS_COUNT
		case $ARGS_COUNT in
		1)	# Split up the only argument passed
			half=$[ ${#FIRST} / 2 ]
			part1="${FIRST:0:$half}"
			part2="${FIRST:$half}"
			tui-printf $optStyleTMP "$part1"
			$doStatus && \
				$0 $optStyle "$NUM_ID" " " "$part2" || \
				$0 $optStyle " " "$part2"
			;;
		2)	# Print each of the 2 arguments on a single line...
			if [ "" = "$(echo $FIRST|tr -d '[[:space:]]')" ]
			then	# It is left aligned
				half=$[ ${#SECOND} / 2 ]
				part1="${SECOND:0:$half}"
				part2="${SECOND:$half}"
				tui-printf $optStyleTMP " " "$part1"
				$doStatus && \
					$0 $optStyle "$NUM_ID" " " "$part2" || \
					$0 $optStyle " " "$part2"
			elif [ $WIDTH -lt ${#FIRST} ]
			then	half=$[ ${#FIRST} / 2 ]
				part1="${FIRST:0:$half}"
				part2="${FIRST:$half}"
				tui-printf $optStyleTMP "$part1"
				# Remains.. still required? -- at least the 'fail' is!
				$doStatus && \
					$0 $optStyle "$NUM_ID" " " "$part2" || \
					$0 $optStyle " " "$part2"
			else	# OLD WORKING
				$0 $optStyleTMP "$FIRST"
				$0 $optStyle " " "$SECOND"
			fi
			;;
		3)	# Print only 2 on the first line
			#  TODO FIXME -- ERORR MUST BE HERE
			if $doStatus
			then	[ -z "$FIRST" ] || tui-printf $optStyleTMP "$FIRST" 
				#echo "$FIRST"
				#echo "$optStyle"
				#echo $NUM_ID
				#echo "$SECOND"
				#exit
				[ ${#SECOND} -gt $WIDTH ] && \
					tui-printf $optStyleTMP " " "${SECOND:0:($WIDTH - 3)}" && \
					tui-printf $optStyle "$NUM_ID" " " "${SECOND:($WIDTH - 3)}"|| \
					tui-printf $optStyle "$NUM_ID" " " "$SECOND"
					
			else	# Regular output, header, title, echo, printf
				# Treat each argument by itself - lengthness
				if [ ${#FIRST} -gt $WIDTH ]
				then	# The first one is too long
					[ -z "$FIRST" ] || tui-printf $optStyleTMP "${FIRST:0:($WIDTH - 2)}"
					[ -z "$SECOND" ] && \
						tui-printf $optStyleTMP " " "${FIRST:($WIDTH - 2)}" || \
						tui-printf $optStyle $NUM_ID "$SECOND"
					#tui-printf $optStyle $NUM_ID #"$THIRD" ""
				elif [ ${#SECOND} -gt $WIDTH ]
				then	# The second one is too long
					[ -z "$FIRST" ] || tui-printf $optStyleTMP "$FIRST" 
					tui-printf $optStyleTMP " " "${SECOND:0:($WIDTH - 3)}"
					tui-printf $optStyle " " "${SECOND:($WIDTH - 3)}" "$THIRD"
				elif [ ${#THIRD} -gt $WIDTH ]
				then	# The third one is too long
					tui-printf $optStyleTMP "$FIRST" "$SECOND"
					tui-printf $optStyle " " "$THIRD" ""
				else	# Regular output, just re-arange strings
					if [ $[ ${#FIRST} + ${#SECOND} ] -lt $WIDTH  ]
					then	tui-printf $optStyleTMP "$FIRST" "$SECOND" " "
						tui-printf $optStyle 	" " 	"$THIRD"
					else	tui-printf $optStyleTMP "$FIRST" 
						tui-printf $optStyle " " 	"$SECOND" "$THIRD"
					fi
				fi
			fi
			;;
		esac
		# Since this is special handling, 
		# calling itself with reduced string lengths
		# so we can exit after this is done
		exit
	# else # just continue with the script below, for regular/final output handline
	fi
#
#	Prepare Colors & Strings
#
	if [ $doEcho = true ] || [ $doStatus = true ]
	then	COLOR_LINE_START="\r${TUI_COLOR_RESET}"
		COLOR_LINE_IDENT=""
		COLOR_LINE_CLOSE=""
		COLOR_LINE_END="${TUI_COLOR_RESET}${NL}${TUI_COLOR_RESET}"
	elif [ $doHeader = true ]
	then	# Full line
		COLOR_LINE_START="\r${HEAD_BG}${HEAD_FG}"
		COLOR_LINE_IDENT=""
		COLOR_LINE_CLOSE=""
		COLOR_LINE_END="${TUI_COLOR_RESET}${NL}${TUI_COLOR_RESET}"
	elif [ $doTitle = true ]
	then	# 'Inlay'
		COLOR_LINE_START="\r${TUI_COLOR_RESET}"
		COLOR_LINE_IDENT="${TITLE_FG}${TITLE_BG}"
		COLOR_LINE_CLOSE="${TUI_COLOR_RESET}"
		COLOR_LINE_END="${TUI_COLOR_RESET}${NL}${TUI_COLOR_RESET}"
	else	# The default
		COLOR_LINE_START="\r${TUI_COLOR_RESET}"
		COLOR_LINE_IDENT=""
		COLOR_LINE_CLOSE=""
		COLOR_LINE_END="${TUI_COLOR_RESET}"
	fi
#
#	Arrange strings in order, with border and colors
#
	# Create POS_ID points, calculated from pos_id_num.
	# pos_id_NUM's
	pos_cli_num=$(( 0 + ${#BORDER_LEFT} + 2 ))
	pos_clc_num=$(( $WIDTH - ${#BORDER_RIGHT} - 2))
	pos_cle_num=$(( $WIDTH - ${#BORDER_RIGHT} ))
	pos_center_num=""
	pos_third_num=""
	# POS_ID
	POS_CLS="\033[0G"	# This is always 0, and therefor doesnt require a pos_id_num calculation
	POS_CLI="\033[${pos_cli_num}G"
	POS_CLC="\033[${pos_clc_num}G"
	POS_CLE="\033[${pos_cle_num}G"
	POS_CENTER=""
	POS_THIRD=""
	
	START="${POS_CLS}${COLOR_LINE_START}${BORDER_LEFT}${COLOR_LINE_IDENT}"
	
	case $ARGS_COUNT in
	#0)	echo nothing todo	;;
	1)	if $doTitle #&& ! $doStatus
		then	SECOND="$FIRST"
			FIRST=" "
			THIRD=" "
			center=$(( $WIDTH / 2 ))
			half=$(( ${#SECOND} / 2 ))
			pos_center_num=$(( $center - $half  ))
			POS_CENTER="\033[${pos_center_num}G"
			SECOND="${POS_CENTER}$SECOND"
		fi			;;
	2)	! $doStatus && \
			THIRD="$SECOND" && \
			SECOND=""
					;;
	3)	center=$(( $WIDTH / 2 ))
		half=$(( ${#SECOND} / 2 ))
		pos_center_num=$(( $center - $half  ))
		POS_CENTER="\033[${pos_center_num}G"
		SECOND="${POS_CENTER}$SECOND"
		;;
	esac
	
	if $doStatus
	then	# That is a difference of 22 (val-1 ; val+21) thats the escape chars for color and reset
		case $NUM_ID in
		0|1|2|3|10|11)	pos_three_adder=21	;;
		4|5|6|7|99)	pos_three_adder=-1	;;
		esac
		pos_third_num=$(( $pos_cle_num + $pos_three_adder - ${#THIRD} ))
		POS_THIRD="\033[${pos_third_num}G"
	else	pos_third_num=$(( $pos_cle_num - 1 - ${#THIRD} ))
		# Fix one position place if there was a %
		echo "$THIRD" | $GREP -q '%' && \
			pos_third_num=$(( $pos_third_num + 1 ))
		POS_THIRD="\033[${pos_third_num}G"
	fi
	IDENT="${POS_CLI}$FIRST"
	CLOSE="${POS_THIRD}$THIRD ${POS_CLC}${COLOR_LINE_CLOSE}"
	END="${POS_CLE}${BORDER_RIGHT}${COLOR_LINE_END}"
#
#	Display & Action
#
	# Escape trailing backslash, from whichever argument passed
	# This is supposed to 'keep' artificial linebreaks rather than get them on one line
        #[ "\\" = "${FIRST:0:(-1)}" ] && \
        #        FIRST="${FIRST}\\"
	if $doTitle || $doHeader
	then	str=$(printf '%*s' $(( $WIDTH - 4)))
		#str="\e[2K"	# See console_codes, for later improvements
	else	str=""
	fi
	printf "${START}${str}${IDENT}"
	printf "${SECOND}"
	printf "${CLOSE}${END}"