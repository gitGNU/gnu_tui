#!/usr/bin/env bash
#
# Copyright (c) 2014-2015 Simon Arjuna Erat (sea)  <erat.simon@gmail.com>
# All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>
#
# ------------------------------------------------------------------------
#
# tui-wait by Simon Arjuna Erat (sea) (erat.simon@gmail.com) on 2014-06-01
#
#	Help text
#
	ME=tui-wait
	script_version=0.5.1
	beVerbose=false
	help_text="
$ME ($script_version)
Usage: 		$ME TIME [MSG]
Examples:	$ME 2m
		$ME 1h \"Until somewhat happens\"
		$ME -v 5 countdown

"
#
#	Argument handling
#
	case "$1" in
	"-h"|"--help"|"")	printf "$help_text"
			exit 1
			;;
	-v)		beVerbose=true
			shift
			;;
	esac
#
#	Variables
#
	TIME="${1/[a-zA-Z]/}"
	UNIT="$(printf ${1}|tr -d [:digit:])"
	[ -z "$TIME" ] && printf "$help_text" && exit 1
	[ -z "$UNIT" ] && UNIT=s
	[ -z "$2" ] && \
		MSG="Time left:" || \
		MSG="$2"
	hours=0
	minutes=0
	seconds=0
	case ${UNIT,,} in
	s)	seconds="$TIME"	;;
	m)	minutes="$TIME"	;;
	h)	hours="$TIME"	;;
	*)	tui-status 1 "Please use either (s)econds, (m)inutes, or (h)ours"
	esac
#
#	Functions
#
	function seconds2time() { #
	# Returns the time as string
	# as much as applicable: hh:mm:ss
		# Calculate values
		secs=$seconds			# Use a temp var
		minutes=$(( $seconds / 60 ))	# This many minutes are found
		sub_s=$(( $minutes * 60 ))	# These minutes represent that many seconds
		secs=$(( $secs - $sub_s ))	# Update the secs
		hours=$(( $minutes / 60 ))	# This many hours from the minutes
		sub_m=$(( $hours  * 60 ))	# These hours represent that many minutes
		minutes=$(( $minutes - $sub_m ))	# Update the remaining minutes
		# Generate strings
		if [ $minutes -gt 0 ] 
		then	[ ${#minutes} -eq 1 ] && \
				[ $hours -gt 0 ] && \
				minutes="0${minutes}:" || \
				minutes+=":"
		else	[ $hours -gt 0 ] && \
				minutes="00:" || \
				minutes=""
		fi
		if [ $secs -gt 0 ] 
		then	[ ${#secs} -eq 1 ] && secs="0${secs}"
		else	secs="00"
		fi
		[ $hours -gt 0 ] && hours="$hours:" || hours=""
		# Output
		echo "${hours}${minutes}${secs}"		
	}
#
#	Action - loop
#
	while [ $seconds -ge 0 ]
	do 	# First display current / passed time
		# Generate string & output to user
		time_string="$(seconds2time $seconds)"
		tui-printf  "$MSG" "$time_string"
		
		# Already reached 0?
		[ "$hours$minutes$seconds" = "000" ] && \
			tui-echo "$MSG" "$NEXT" && \
			exit 0
		
		# So subtract, its a countdown
		((seconds--))
		if [ $seconds -lt 0 ]
		then 	# We have sub zero seconds, fix that
			seconds=59
			((minutes--)) 
			# While minutes changes, check for hour changes
			[ $minutes -lt 0 ] && minutes=59 && ((hours--))
			[ $hours -lt 0 ] && hours=0
		fi
		
		# Actualy wait a second
		$beVerbose && printf "\n"
		sleep 1
	done
	exit 0
