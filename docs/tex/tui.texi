\input texinfo   @c -*-texinfo-*-
@comment %**start of header
@setfilename tui.info
@include _version.texi
@settitle Manual 1.0 for Text User Interface (TUI)
@syncodeindex pg cp
@comment %**end of header
@copying
This manual is for TUI (version @value{VERSION}, @value{UPDATED})
Copyright @copyright{} 2011-2015 Simon Arjuna Erat
TUI is licensed as GPLv3.
The manual is licensed as GFDL.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
@end quotation
@end copying

@documentdescription
gnu,linux,script,bash,ash,csh,zsh,tui,cli
@end documentdescription

@comment ## --------------------------------------------------------------- ##

@titlepage
@title Table of Content
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Simon Arjuna Erat (@email{erat.simon@@gmail.com})
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage


@comment ## --------------------------------------------------------------- ##

@ifnottex
@node Top
@top GNU TUI
This manual is for TUI (version @value{VERSION}, @value{UPDATED}).
@end ifnottex

TUI is a command based Text User Interface framework for scripts.

Allthough it requires BASH to be installed, the commands can be called from other SHELLS as well.
But be aware of their differences, such as string formatting and possible exit codes as examples.

@menu
* Introduction to TUI :: 
* Installation :: Optimal installation & deinstalllation
* Configuration :: What is where done
* Usage :: Some basic description
@c * Display Commands :: The definition of Interface
@c * Interactive Commands :: Convenience for author and user
@c * Advanced Commands :: Tools for the crazy lazy geeks with great ideas
* Appendix :: 
@end menu
@contents

@comment ## --------------------------------------------------------------- ##

@node Introduction to TUI
@chapter Introduction to TUI
@i {TUI is a bash framework to write scripts with a Text User Interface.}

It is a command based framework which wraps the task (executed command name represents task or 
description) into an adaptive Text User Interface (TUI).
It is a framework to be used in the shell or shell scripts, though the usage of scripts is recommended 
to preserve the interface feeling.

It was the core display part of another script-dream I have, and it took me almost 2.5 years 
until i figured that extracting all these displaying functions, provide its very own project.
TUI was born, a command based framework to give scripts an interface like feeling.

This said, when executed alone, a single tui-<command>, it doesn't look that much like an interface.
However, as soon you append a few tui-echo after another or use tui-cat to print a small text file to
the screen, you will feel the difference.

Many script authors write their collection of code helpers, display features or task assistants.
As such functions, they have to copy them to each of the scripts, 
and manually maintain and adjust the function inside that script, 
or update all those scripts just to be sure that function is updated.

TUI jumps in here, providing a 3-Way-Interface between the Author of a script, 
the System (and its installed software) and the User who is executing it.

In fact, TUI is tui!

'tui' is meant to make a directory a simple but highly configurable script menu, and display its 
sub-directories as sections and browse among the tree structure, with its entrance point as root.
All the other commands, are merely the code helpers, display tools, list library, variable providers,
gathered as commands for easy availability, so you can access them straight forward like any command 
in your scripts.

You as the author of the script, don't have to worry about software the user has installed, 
instead you call: tui-edit, tui-filemgr, tui-web or tui-terminal (tui-terimnal is GUI only), 
or which distribution the user is using, simply call tui-install to cover package manager 
installations from Arch, over *BSD and Debian to Fedora/Red-Hat to Slackware or Tizen.


It brings together the best of two worlds, the power of the console and the convenience of a graphical
environment.


@comment ## --------------------------------------------------------------- ##


@node Installation
@chapter Installation
@section Getting the code
It is recomended by FHS (http://www.pathname.com/fhs/pub/fhs-2.3.html#USRSRCSOURCECODE) to save source code in /usr/src.
@example
    su
    cd /usr/src
    git clone https://github.com/sri-arjuna/tui.git
    cd tui
@end example

@section A basic installation procedure looks like:
@example
    ./configure --prefix=/
    make
    make install
@end example

By default this will install TUI using the default prefix /usr/local, so the binaries will be available in PREFIX/bin.

@section Uninstall
@example
    su
    cd /usr/src/tui
    make uninstall
@end example


@comment ## --------------------------------------------------------------- ##


@node Configuration
@chapter Configuration
Is done either by the (End-)User, the applications installed and the system the user is using.
Default themes are 'default' for the user, and 'default-red' for root.

First and for the most, you can change the theme.
A theme defines the left and right border, the font and background color of tui-header and tui-title,
as well as the input character for tui-select.

Application invokes by either one of tui-edit, tui-filemgr, tui-web or tui-terminal which will search through
a list of known applications, diverted by cli or gui abilities if the default applications are not found.
If you have WINE installed, it may happend that 'notepad' is started as editor rather than 'scribes'.

If your favorite application is missing on its list, please contact the author of TUI to append it/them.

Calling
@example
    tuirc config
@end example
will bring up a screen to select which conf file to edit.

@section Apps / @sc {$TUI_FILE_USER_CONF}
Upon first call, you will probably see the values listed as variable names with a '$'-prefix.
This setting will use the system defaults set in /etc/tui/apps.conf.
If you are calling the above command as root, you will edit the system defaults, and not the user preferences.
CURLWGET will be 'curl' or 'wget' if found, if neither is found, tui-download will ask to install either one.

@section Loadlist
Can only be edited, but should not be changed or expaned.
This file defines the order in which the user configs are read.
You may add custom entries, but be aware these functions or values will not be available if you share your scripts using them.

@section Settings / @sc {$TUI_FILE_USER_SETTINGS}
Here, the behaviour or default values for tui-commands is defined.




@comment ## --------------------------------------------------------------- ##


@node Usage
@chapter Usage
This is a summary description of each command, grouped into different cathegories.

If you are looking for @b {code samples}, try:
@example
    tuirc samples
@end example

@section Display Commands
Usualy scripts not only summarizes several commands into a single file, it also enables us to display 'selected information'.

This handles the commands that are used to display information to the user.


@subsection tui-printf
This is the heart of TUI, as it provides the core functionality to display everything TUI will display.
But usualy you will use it to update the current printed line of the previous/initial call of tui-printf.

It handles up to three (3) quoted strings, printing the first one on the left side.
If there are 2 strings passed, the 2nd will be on the right side.
If there are 3 strings passed, the 2nd will be in the center, and the 3rd on the right side.

@subsection tui-echo
Like its regular counterpart @b {echo}, but provides the same output alignment as tui-printf.

@subsection tui-header
With its full line  background color, tui-header is ment - where applicable - as 'constant' header/footer of a loop based script.
Or just as a one time application information header.

@subsection tui-title
Is using the inverted colors of tui-header, having only the inlay line with a background.

tui-title handles the first string argument differently, as it centers it.
With any further string argument, it behaves like the others.


@subsection tui-list
Is nice handy tool to print different kinds of list.
* no numbering
* arabic numbering (regular)
* roman numbering (from 1 to 9999)
* alphabetic numbering


@subsection tui-cat
A basic tool to display small script/text files.

It also provides a Typewriter mode, which accepts strings as well.

@subsection tui-progress
A very powerfull tool to display several kinds of different progress indications.

From a single animated dash, simple numbering, numbering up to a max value,
and even a progress bar with additional percent display.

@subsection tui-status
A nice and handy tool to display the exit code of the previous condition.

Allthough thought to help to display either success or failure of a task, it provides much more.


@comment ## --------------------------------------------------------------- ##

@section Interactive Commands
Ever wanted to start an editor at a users computer, but he had not installed it?

Dont worry, the interactive tools provide a soltution for this, and more.

@subsection tui-yesno
One of the most used tools in TUI, a simple bool returning command showing a question to the user.


@subsection tui-download
Has the user curl or wget installed, both or none?

Dont worry, this tool handles this, it selects the first command found (or set in the configuration) to download.

While it does show how much data it downloaded (filesize), it cant show a progressbar - this is in plan but very low prio.

@subsection tui-edit
So, you want the user to edit a file, but dont konw which editor he has installed?

Call tui-edit, it looks for default editors, if none is found, it searches a list of known ones, 
if none is found it asks the user to install one of the known ones.

@subsection tui-filemgr
So, you want the user to see some file, but dont konw which filemanager he has installed?

Call tui-filemgr, it looks for default filemanagers, if none is found, it searches a list of known ones, 
if none is found it asks the user to install one of the known ones.

@subsection tui-press
Does what it says, asks the user to 'press enter to continue'.

@subsection tui-read
Well, it reads the user input

@subsection tui-select
Select an item from passed arguments.
If your 'read' supports it, it wont require 'enter' to select an item which its digit count is as long as the digit count of the arguments passed (eg: item 10 of 99)
If you want to select item 1 out of 11, you will have to press 'enter' though.

@subsection tui-terminal
Obviously this will only work in GUI mode and will open the selected/prefered terminal emulator.

@subsection tui-wait
Waits given time (s/m/h), counting down and showing optional message.

@subsection tui-web
Well, firefox might be a good choice, but some people dont have it installed, this takes care of it,
just like tui-edit, tui-filemgr, and tui-terminal.


@comment ## --------------------------------------------------------------- ##

@section Code Helpers (groups)
Small things to make your life easier, sorted by groups.

@subsection tui-bol-dir
Returns true if passed dir was found or could be created.
Shows tui-status if verbose.

@subsection tui-bol-gui
Returns true if the user is in GUI mode.
Returns DE name if verbose.

@subsection tui-bol-root
Returns true if user is root.

@subsection tui-conf-editor
A basic tool to edit a (basic) conf file.

@subsection tui-conf-get
Gets the value of a variable from a file.

@subsection tui-conf-set
Set the value of a variable in a file.

@subsection tui-str-bol-conv
Converts '0|1|$?' (return codes) to text.

done/fail ; true/false ; yes/no

@subsection tui-str-extension
Returns the last string after a dot, empty if no dot is found.

@subsection tui-str-genfilename
Generates a numbered file, optinaly sets a new file extension.

@subsection tui-str-hash
Hashes a passed string to different sha's or md5.

@subsection tui-str-usb
Lets the user select an USB storage and returns the device path. (/dev/sdx)


@section Code Helpers (singles)

@subsection tui-asroot
Executes passed (quoted) command as root, uses sudo where applicable or set.

@subsection tui-cp
Copy a file, displays progress bar.

@subsection tui-dd
Thought to wrtie images to usb devices.

Need feedback to cover more use cases.

@subsection tui-mv
Moves a file, displays a progress bar.

@subsection tui-tar
Tarballs a directory or file.


@comment ## --------------------------------------------------------------- ##


@section Advanced Commands
The tools provides in this section are usualy for those who just want more.

@subsection tui-bgjob
Executes a script in background.

Prints first string while running, second when done.

@subsection tui-bgjob-mgr
Executes multiple scripts at once. 

Lets you define how many scripts shall run simultainiously.

Can run in quiet mode and return (as exit code) how many scripts were ended with success.

@subsection tui-install
Can be used to identify what distro the system is.

Is ment to install dependencies that might be found in the distro its repositry.

@subsection tui-log
A tool to manage/write your custom logfiles.


@comment ## --------------------------------------------------------------- ##

@section tui
This command is the core element and was the main purpose for me to write TUI.

It is THE automated menu you were always looking for.

Define a folder as your home menu, pass that folder as the '-p dir', to use as as browsable menu.
You can even direct access scripts in subfolders straight from the command line.

Scripts executed by 'tui' dont have to be in BASH, though, if they are not BASH, you must set the 'SHELL' with '-x' and all files shown must be that SHELL.
Note, that in this case, SHELL could also be: Python or Perl, aside from ash, csh, zsh...


@node Appendix
@chapter Appendix

@section History


@section Idea
In todays world, everything is about presenting. There are many tasks that can be faster accomplished using a script rather than writing an application for it as others require to use it.
This said, it is known many end-users dont like the terminal screen. That is usualy because the commands in terminals have their output not very well structured, usualy just text-by-text-by-newline-by-text.
This is if you need/want/have to provide scripts for users to use, and make it (a little) easier for them to 'read' the terminal, without to have to write 'presentation' handlers.
Thus user.conf in ~/.config/tui provides variables that may be used for any script that sources tui, same goes for apps.conf, which will provide EDITOR, BROWSER, FILEMGR, TERMINAL with your set favorite applications.
Now in the combination with tui-edit, you dont even need to source tuirc to have tui-edit open the given filename with your favorite editor.



@bye
